package com.obfuscate.processor

import com.google.devtools.ksp.getDeclaredProperties
import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.processing.SymbolProcessorEnvironment
import com.google.devtools.ksp.processing.SymbolProcessorProvider
import com.google.devtools.ksp.symbol.FileLocation
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSPropertyDeclaration
import com.google.devtools.ksp.validate
import com.obfuscate.annotation.StringObfuscate
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeName
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.ksp.writeTo
import java.nio.file.Files
import java.nio.file.Paths
import java.security.SecureRandom
import java.util.Base64

private val STRING_TYPE = ClassName("kotlin", "String")
private val BYTE_TYPE = ClassName("kotlin", "Byte")
private val BYTE_ARRAY_TYPE = ClassName("kotlin", "ByteArray")
private val ARRAY_OF_STRING = ClassName("kotlin", "Array").parameterizedBy(STRING_TYPE)
private val LIST_OF_STRING = ClassName("kotlin.collections", "List").parameterizedBy(STRING_TYPE)
private val MUTABLE_LIST_OF_STRING = ClassName("kotlin.collections", "MutableList").parameterizedBy(STRING_TYPE)
private val SET_OF_STRING = ClassName("kotlin.collections", "Set").parameterizedBy(STRING_TYPE)
private val MUTABLE_SET_OF_STRING = ClassName("kotlin.collections", "MutableSet").parameterizedBy(STRING_TYPE)

class StringObfuscateProcessor(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger
) : SymbolProcessor {

    private val secureRandom = SecureRandom()
    private val fileContentCache = mutableMapOf<String, String>()
    private val methodCallPatterns = setOf(
        "System.getProperty",
        "System.getenv",
        "java.lang.System.getProperty",
        "java.lang.System.getenv"
    )

    override fun process(resolver: Resolver): List<KSAnnotated> {
        val symbols = resolver.getSymbolsWithAnnotation(StringObfuscate::class.qualifiedName!!)
        val validSymbols = symbols.filter { it is KSClassDeclaration && it.validate() }

        validSymbols.forEach { symbol ->
            if (symbol is KSClassDeclaration) {
                processClass(symbol)
            }
        }

        return symbols.filterNot { it.validate() }.toList()
    }

    private fun processClass(classDeclaration: KSClassDeclaration) {
        val packageName = classDeclaration.packageName.asString()
        val className = classDeclaration.simpleName.asString()
        val generatedClassName = "${className}Obfuscated"

        logger.info("Processing @StringObfuscate on $packageName.$className")

        val propertyInfos = collectPropertyInfos(classDeclaration)

        if (propertyInfos.isEmpty()) {
            logger.warn("No obfuscatable string values found in $className")
            return
        }

        val fileSpec = FileSpec.builder(packageName, generatedClassName)
            .addFileComment("Generated by StringObfuscate KSP - DO NOT EDIT")
            .addImport("android.util", "Base64")
            .addType(generateObfuscatedClass(className, propertyInfos))
            .build()

        classDeclaration.containingFile?.let {
            fileSpec.writeTo(codeGenerator, Dependencies(true, it))
        } ?: logger.error("Unable to determine containing file for $packageName.$className")
    }

    private fun collectPropertyInfos(classDeclaration: KSClassDeclaration): List<PropertyInfo> {
        val propertyInfos = mutableListOf<PropertyInfo>()

        // Process regular properties
        classDeclaration.getDeclaredProperties()
            .filter { it.parentDeclaration == classDeclaration }
            .filterNot { shouldSkipProperty(it) }
            .forEach { property ->
                val kind = determinePropertyKind(property) ?: return@forEach
                when (kind) {
                    PropertyKind.STRING -> {
                        val value = extractStringValue(property)
                        if (value == null) {
                            logger.warn("Skipping ${property.simpleName.asString()} ‚Äì unable to resolve string literal")
                        } else if (shouldSkipStringValue(value)) {
                            logger.info("Skipping ${property.simpleName.asString()} ‚Äì matches ignore pattern: $value")
                        } else {
                            propertyInfos.add(PropertyInfo(property.simpleName.asString(), kind, listOf(value)))
                        }
                    }

                    PropertyKind.STRING_ARRAY,
                    PropertyKind.LIST,
                    PropertyKind.MUTABLE_LIST,
                    PropertyKind.SET,
                    PropertyKind.MUTABLE_SET -> {
                        val values = extractStringCollection(property)
                        if (values == null) {
                            logger.warn("Skipping ${property.simpleName.asString()} ‚Äì unable to resolve string collection literal")
                        } else {
                            val filteredValues = values.filterNot { shouldSkipStringValue(it) }
                            if (filteredValues.isNotEmpty()) {
                                propertyInfos.add(PropertyInfo(property.simpleName.asString(), kind, filteredValues))
                            } else {
                                logger.info("Skipping ${property.simpleName.asString()} ‚Äì all values match ignore patterns")
                            }
                        }
                    }
                }
            }

        // Process method calls within the class (experimental)
        processMethodCalls(classDeclaration, propertyInfos)

        return propertyInfos
    }

    private fun processMethodCalls(classDeclaration: KSClassDeclaration, propertyInfos: MutableList<PropertyInfo>) {
        // Advanced method call obfuscation would require AST transformation capabilities
        // that KSP doesn't provide. However, we can detect and warn about method calls.

        classDeclaration.getDeclaredProperties()
            .filter { it.parentDeclaration == classDeclaration }
            .forEach { property ->
                val methodCall = extractMethodCall(property)
                if (methodCall != null) {
                    logger.warn("‚ö†Ô∏è  Method call detected in ${property.simpleName.asString()}: $methodCall")
                    logger.warn("   üí° Consider wrapping this call or using obfuscated parameters:")
                    logger.warn("      fun getSafeProxyHost() = System.getProperty(${classDeclaration.simpleName.asString()}Obfuscated.getProxyHostKey())")
                }
            }
    }

    private fun extractMethodCall(property: KSPropertyDeclaration): String? {
        val file = property.containingFile ?: return null
        val location = property.location as? FileLocation ?: return null
        val content = readFileContent(file.filePath)
        val offset = computeLineOffset(content, location.lineNumber) ?: return null
        val tail = content.substring(offset)

        val name = property.simpleName.asString()
        val declarationRegex = Regex("\\b(?:const\\s+)?(?:val|var)\\s+${Regex.escape(name)}\\b")
        val match = declarationRegex.find(tail) ?: return null

        var equalsIndex = match.range.last + 1
        while (equalsIndex < tail.length) {
            val ch = tail[equalsIndex]
            if (ch == '=') {
                val prev = tail.getOrNull(equalsIndex - 1)
                if (prev != '=' && prev != '!' && prev != '<' && prev != '>') {
                    equalsIndex++
                    break
                }
            }
            equalsIndex++
        }
        if (equalsIndex >= tail.length) return null

        val expressionStart = skipWhitespace(tail, equalsIndex)
        val expression = tail.substring(expressionStart).trim()

        // Check if it's a method call we recognize
        methodCallPatterns.forEach { pattern ->
            if (expression.startsWith(pattern)) {
                return expression
            }
        }

        return null
    }

    private fun generateObfuscatedClass(
        originalName: String,
        properties: List<PropertyInfo>
    ): TypeSpec {
        val pairType = ClassName("kotlin", "Pair").parameterizedBy(BYTE_ARRAY_TYPE, BYTE_TYPE)
        val listOfPairsType = ClassName("kotlin.collections", "List").parameterizedBy(pairType)
        val mapType = ClassName("kotlin.collections", "Map").parameterizedBy(STRING_TYPE, listOfPairsType)

        val classBuilder = TypeSpec.objectBuilder("${originalName}Obfuscated")
            .addKdoc(
                "Obfuscated version of %L\nGenerated at compile time for security",
                originalName
            )
            .addProperty(
                PropertySpec.builder("obfuscatedData", mapType, KModifier.PRIVATE)
                    .initializer(buildObfuscatedDataMap(properties))
                    .build()
            )

        properties.forEach { info ->
            classBuilder.addFunction(generateAccessor(info))
        }

        classBuilder.addFunction(generateDeobfuscateFunction())

        return classBuilder.build()
    }

    private fun buildObfuscatedDataMap(properties: List<PropertyInfo>): CodeBlock {
        if (properties.isEmpty()) {
            return CodeBlock.of("emptyMap()")
        }

        val block = CodeBlock.builder()
        block.add("mapOf(\n")
        block.indent()

        properties.forEachIndexed { propertyIndex, info ->
            val obfuscatedValues = info.values.map { obfuscateString(it) }

            if (obfuscatedValues.isEmpty()) {
                block.add("%S to emptyList()", info.name)
            } else {
                block.add("%S to listOf(\n", info.name)
                block.indent()
                obfuscatedValues.forEachIndexed { index, value ->
                    block.add(buildObfuscatedEntry(value))
                    if (index < obfuscatedValues.lastIndex) {
                        block.add(",\n")
                    }
                }
                block.unindent()
                block.add("\n)")
            }

            if (propertyIndex < properties.lastIndex) {
                block.add(",\n")
            }
        }

        block.unindent()
        block.add("\n)")
        return block.build()
    }

    private fun buildObfuscatedEntry(value: ObfuscatedValue): CodeBlock {
        val base64Encoded = if (value.bytes.isEmpty()) {
            "\"\""
        } else {
            "\"${Base64.getEncoder().encodeToString(value.bytes)}\""
        }

        return CodeBlock.of("(android.util.Base64.decode(%L, android.util.Base64.DEFAULT) to %L)", base64Encoded, "${value.key}.toByte()")
    }

    private fun generateAccessor(info: PropertyInfo): FunSpec {
        val accessorName = "get${info.name.toAccessorSuffix()}"
        val builder = FunSpec.builder(accessorName)
            .returns(info.kind.returnType)

        when (info.kind) {
            PropertyKind.STRING -> builder.addCode(
                CodeBlock.builder()
                    .add("val entry = obfuscatedData[%S]!![0]\n", info.name)
                    .add("return deobfuscate(entry.first, entry.second)\n")
                    .build()
            )

            PropertyKind.STRING_ARRAY -> builder.addCode(
                CodeBlock.builder()
                    .add("val entries = obfuscatedData[%S]!!\n", info.name)
                    .add(
                        "return entries.map { entry -> deobfuscate(entry.first, entry.second) }.toTypedArray()\n"
                    )
                    .build()
            )

            PropertyKind.LIST -> builder.addCode(
                CodeBlock.builder()
                    .add("val entries = obfuscatedData[%S]!!\n", info.name)
                    .add("return entries.map { entry -> deobfuscate(entry.first, entry.second) }\n")
                    .build()
            )

            PropertyKind.MUTABLE_LIST -> builder.addCode(
                CodeBlock.builder()
                    .add("val entries = obfuscatedData[%S]!!\n", info.name)
                    .add(
                        "return entries.map { entry -> deobfuscate(entry.first, entry.second) }.toMutableList()\n"
                    )
                    .build()
            )

            PropertyKind.SET -> builder.addCode(
                CodeBlock.builder()
                    .add("val entries = obfuscatedData[%S]!!\n", info.name)
                    .add("return entries.map { entry -> deobfuscate(entry.first, entry.second) }.toSet()\n")
                    .build()
            )

            PropertyKind.MUTABLE_SET -> builder.addCode(
                CodeBlock.builder()
                    .add("val entries = obfuscatedData[%S]!!\n", info.name)
                    .add(
                        "return entries.map { entry -> deobfuscate(entry.first, entry.second) }.toMutableSet()\n"
                    )
                    .build()
            )
        }

        return builder.build()
    }

    private fun generateDeobfuscateFunction(): FunSpec {
        return FunSpec.builder("deobfuscate")
            .addModifiers(KModifier.PRIVATE, KModifier.INLINE)
            .addParameter("encoded", BYTE_ARRAY_TYPE)
            .addParameter("key", BYTE_TYPE)
            .returns(STRING_TYPE)
            .addCode(
                """
                // Optimized readonly span deobfuscation - in-place operations for maximum performance
                for (i in encoded.indices) {
                    val b = encoded[i].toInt() and 0xFF
                    // Reverse bit shuffle: (b >> 3) | (b << 5) & 0xFF
                    val unshuffled = ((b shr 3) or (b shl 5)) and 0xFF
                    // XOR decryption in-place
                    encoded[i] = (unshuffled xor key.toInt()).toByte()
                }
                return String(encoded, Charsets.UTF_8)
                """.trimIndent()
            )
            .build()
    }

    private fun shouldSkipProperty(property: KSPropertyDeclaration): Boolean {
        val propertyName = property.simpleName.asString().lowercase()

        // Skip properties with names that suggest logging/debugging
        val skipPatterns = listOf(
            "log", "debug", "print", "trace", "verbose", "info", "warn", "error",
            "tag", "message", "msg"
        )

        return skipPatterns.any { pattern ->
            propertyName.contains(pattern)
        }
    }

    private fun shouldSkipStringValue(value: String): Boolean {
        // Skip strings that are likely used for logging, debugging, or system properties
        val skipPatterns = listOf(
            // Logging patterns
            Regex("log\\s*\\w*", RegexOption.IGNORE_CASE),
            Regex("print\\s*\\w*", RegexOption.IGNORE_CASE),
            Regex("debug\\s*\\w*", RegexOption.IGNORE_CASE),

            // System property patterns
            Regex(".*\\..*\\..*", RegexOption.IGNORE_CASE), // dotted patterns like http.proxyHost
            Regex(".*proxy.*", RegexOption.IGNORE_CASE),
            Regex(".*host.*", RegexOption.IGNORE_CASE),

            // Common system properties
            Regex("java\\..*", RegexOption.IGNORE_CASE),
            Regex("android\\..*", RegexOption.IGNORE_CASE),
            Regex("os\\..*", RegexOption.IGNORE_CASE),
            Regex("user\\..*", RegexOption.IGNORE_CASE),

            // Network related
            Regex("localhost", RegexOption.IGNORE_CASE),
            Regex("127\\.0\\.0\\.1", RegexOption.IGNORE_CASE),
            Regex("::1", RegexOption.IGNORE_CASE),
            Regex("0\\.0\\.0\\.0", RegexOption.IGNORE_CASE)
        )

        return skipPatterns.any { pattern ->
            pattern.matches(value)
        }
    }

    private fun determinePropertyKind(property: KSPropertyDeclaration): PropertyKind? {
        val resolvedType = property.type.resolve()
        val qualified = resolvedType.declaration.qualifiedName?.asString() ?: return null

        return when (qualified) {
            "kotlin.String" -> PropertyKind.STRING
            "kotlin.Array" -> {
                val argument = resolvedType.arguments.singleOrNull()?.type?.resolve()
                if (argument?.declaration?.qualifiedName?.asString() == "kotlin.String") {
                    PropertyKind.STRING_ARRAY
                } else {
                    null
                }
            }

            "kotlin.collections.List" -> {
                val argument = resolvedType.arguments.singleOrNull()?.type?.resolve()
                if (argument?.declaration?.qualifiedName?.asString() == "kotlin.String") {
                    PropertyKind.LIST
                } else {
                    null
                }
            }

            "kotlin.collections.MutableList" -> {
                val argument = resolvedType.arguments.singleOrNull()?.type?.resolve()
                if (argument?.declaration?.qualifiedName?.asString() == "kotlin.String") {
                    PropertyKind.MUTABLE_LIST
                } else {
                    null
                }
            }

            "kotlin.collections.Set" -> {
                val argument = resolvedType.arguments.singleOrNull()?.type?.resolve()
                if (argument?.declaration?.qualifiedName?.asString() == "kotlin.String") {
                    PropertyKind.SET
                } else {
                    null
                }
            }

            "kotlin.collections.MutableSet" -> {
                val argument = resolvedType.arguments.singleOrNull()?.type?.resolve()
                if (argument?.declaration?.qualifiedName?.asString() == "kotlin.String") {
                    PropertyKind.MUTABLE_SET
                } else {
                    null
                }
            }

            else -> null
        }
    }

    private fun extractStringValue(property: KSPropertyDeclaration): String? {
        val parsed = property.parsedInitializer() as? ParsedInitializer.StringLiteral ?: return null
        return evaluateStringExpression(parsed.expression)
    }

    private fun extractStringCollection(property: KSPropertyDeclaration): List<String>? {
        val parsed = property.parsedInitializer() as? ParsedInitializer.CollectionLiteral ?: return null
        return parsed.expressions.map { evaluateStringExpression(it) }
    }

    private fun KSPropertyDeclaration.parsedInitializer(): ParsedInitializer? {
        val file = containingFile ?: return null
        val location = location as? FileLocation ?: return null
        val content = readFileContent(file.filePath)
        val offset = computeLineOffset(content, location.lineNumber) ?: return null
        val tail = content.substring(offset)

        val name = simpleName.asString()
        val declarationRegex = Regex("\\b(?:const\\s+)?(?:val|var)\\s+${Regex.escape(name)}\\b")
        val match = declarationRegex.find(tail) ?: return null

        var equalsIndex = match.range.last + 1
        while (equalsIndex < tail.length) {
            val ch = tail[equalsIndex]
            if (ch == '=') {
                val prev = tail.getOrNull(equalsIndex - 1)
                if (prev != '=' && prev != '!' && prev != '<' && prev != '>') {
                    equalsIndex++
                    break
                }
            }
            equalsIndex++
        }
        if (equalsIndex >= tail.length) return null

        val expressionStart = skipWhitespace(tail, equalsIndex)

        parseStringExpression(tail, expressionStart)?.let { result ->
            return ParsedInitializer.StringLiteral(result.expression)
        }

        parseCollectionExpression(tail, expressionStart)?.let { result ->
            return ParsedInitializer.CollectionLiteral(result.elements)
        }

        return null
    }

    private fun readFileContent(path: String): String {
        return fileContentCache.getOrPut(path) {
            Files.readString(Paths.get(path))
        }
    }

    private fun computeLineOffset(text: String, targetLine: Int): Int? {
        if (targetLine <= 1) return 0
        var line = 1
        var index = 0
        val length = text.length
        while (index < length) {
            val ch = text[index]
            when (ch) {
                '\n' -> {
                    line++
                    index++
                    if (line == targetLine) return index
                }

                '\r' -> {
                    line++
                    if (line == targetLine) {
                        return if (index + 1 < length && text[index + 1] == '\n') index + 2 else index + 1
                    }
                    index++
                    if (index < length && text[index] == '\n') {
                        index++
                    }
                }

                else -> index++
            }
        }
        return if (line == targetLine) length else null
    }

    private fun parseStringExpression(text: String, start: Int): StringExpressionResult? {
        val literalEnd = when {
            text.startsWith("\"\"\"", start) -> findTripleQuoteEnd(text, start)
            text.getOrNull(start) == '"' -> findDoubleQuoteEnd(text, start)
            else -> -1
        }
        if (literalEnd == -1) return null

        val literal = text.substring(start, literalEnd)
        var current = literalEnd
        val modifiers = mutableListOf<StringModifier>()

        while (true) {
            val next = skipWhitespace(text, current)
            when {
                text.startsWith(".trimIndent()", next) -> {
                    modifiers += StringModifier.TrimIndent
                    current = next + ".trimIndent()".length
                }

                text.startsWith(".trimMargin()", next) -> {
                    modifiers += StringModifier.TrimMargin(null)
                    current = next + ".trimMargin()".length
                }

                text.startsWith(".trimMargin(", next) -> {
                    val (prefix, endIndex) = parseTrimMarginSuffix(text, next) ?: return null
                    modifiers += StringModifier.TrimMargin(prefix)
                    current = endIndex
                }

                else -> return StringExpressionResult(StringExpression(literal, modifiers), current)
            }
        }
    }

    private fun parseTrimMarginSuffix(text: String, start: Int): Pair<String?, Int>? {
        var index = start + ".trimMargin(".length
        index = skipWhitespace(text, index)
        if (index >= text.length) return null

        if (text[index] == ')') {
            return null to index + 1
        }

        val literalResult = parseStringExpression(text, index) ?: return null
        if (literalResult.expression.modifiers.isNotEmpty()) {
            return null
        }
        val prefix = evaluateStringExpression(literalResult.expression)
        index = skipWhitespace(text, literalResult.endIndex)
        if (index >= text.length || text[index] != ')') return null
        return prefix to (index + 1)
    }

    private fun parseCollectionExpression(text: String, start: Int): CollectionExpressionResult? {
        val initializerName = SUPPORTED_COLLECTION_INITIALIZERS.firstOrNull { text.startsWith(it, start) } ?: return null
        var index = start + initializerName.length

        if (index < text.length && text[index] == '<') {
            val genericsEnd = findMatchingClose(text, index, '<', '>')
            if (genericsEnd == -1) return null
            index = genericsEnd
        }

        index = skipWhitespace(text, index)
        if (index >= text.length || text[index] != '(') return null
        index++

        val elements = mutableListOf<StringExpression>()
        var current = index

        while (current < text.length) {
            current = skipWhitespace(text, current)
            if (current >= text.length) return null

            if (text[current] == ')') {
                return CollectionExpressionResult(elements, current + 1)
            }

            val elementResult = parseStringExpression(text, current) ?: return null
            elements += elementResult.expression
            current = skipWhitespace(text, elementResult.endIndex)

            if (current < text.length && text[current] == ',') {
                current++
                continue
            }

            if (current < text.length && text[current] == ')') {
                return CollectionExpressionResult(elements, current + 1)
            }
        }

        return null
    }

    private fun evaluateStringExpression(expression: StringExpression): String {
        val base = when {
            expression.literal.startsWith("\"\"\"") -> expression.literal.substring(3, expression.literal.length - 3)
            expression.literal.startsWith("\"") -> unescapeKotlinString(expression.literal.substring(1, expression.literal.length - 1))
            else -> ""
        }

        return expression.modifiers.fold(base) { acc, modifier ->
            when (modifier) {
                StringModifier.TrimIndent -> acc.trimIndent()
                is StringModifier.TrimMargin -> {
                    val prefix = modifier.prefix
                    if (prefix != null) acc.trimMargin(prefix) else acc.trimMargin()
                }
            }
        }
    }

    private fun skipWhitespace(text: String, start: Int): Int {
        var index = start
        while (index < text.length && text[index].isWhitespace()) {
            index++
        }
        return index
    }

    private fun findDoubleQuoteEnd(text: String, start: Int): Int {
        var index = start + 1
        while (index < text.length) {
            val ch = text[index]
            if (ch == '\\') {
                index += 2
            } else if (ch == '"') {
                return index + 1
            } else {
                index++
            }
        }
        return -1
    }

    private fun findTripleQuoteEnd(text: String, start: Int): Int {
        var index = start + 3
        while (index < text.length - 2) {
            if (text[index] == '"' && text[index + 1] == '"' && text[index + 2] == '"') {
                return index + 3
            }
            index++
        }
        return -1
    }

    private fun findMatchingClose(text: String, start: Int, open: Char, close: Char): Int {
        var depth = 0
        var index = start
        while (index < text.length) {
            val ch = text[index]
            if (ch == open) {
                depth++
            } else if (ch == close) {
                depth--
                if (depth == 0) {
                    return index + 1
                }
            }
            index++
        }
        return -1
    }

    private fun unescapeKotlinString(value: String): String {
        val result = StringBuilder(value.length)
        var index = 0
        while (index < value.length) {
            val ch = value[index]
            if (ch == '\\') {
                if (index + 1 >= value.length) {
                    result.append('\\')
                    break
                }
                val next = value[index + 1]
                when (next) {
                    'n' -> {
                        result.append('\n')
                        index += 2
                    }

                    't' -> {
                        result.append('\t')
                        index += 2
                    }

                    'r' -> {
                        result.append('\r')
                        index += 2
                    }

                    'b' -> {
                        result.append('\b')
                        index += 2
                    }

                    'f' -> {
                        result.append('\u000C')
                        index += 2
                    }

                    '\\' -> {
                        result.append('\\')
                        index += 2
                    }

                    '\'' -> {
                        result.append('\'')
                        index += 2
                    }

                    '"' -> {
                        result.append('"')
                        index += 2
                    }

                    '$' -> {
                        result.append('$')
                        index += 2
                    }

                    'u' -> {
                        if (index + 5 < value.length) {
                            val hex = value.substring(index + 2, index + 6)
                            val code = hex.toIntOrNull(16)
                            if (code != null) {
                                result.append(code.toChar())
                                index += 6
                            } else {
                                result.append("\\u")
                                index += 2
                            }
                        } else {
                            result.append("\\u")
                            index += 2
                        }
                    }

                    else -> {
                        result.append(next)
                        index += 2
                    }
                }
            } else {
                result.append(ch)
                index++
            }
        }
        return result.toString()
    }

    private fun obfuscateString(input: String): ObfuscatedValue {
        val xorKey = secureRandom.nextInt(256)

        val xored = input.toByteArray(Charsets.UTF_8)
            .map { (it.toInt() xor xorKey).toByte() }
            .toByteArray()

        val shuffled = xored.map { byte ->
            val value = byte.toInt() and 0xFF
            ((value shl 3) or (value ushr 5)) and 0xFF
        }.map { it.toByte() }.toByteArray()

        return ObfuscatedValue(shuffled, xorKey)
    }

    private data class ObfuscatedValue(val bytes: ByteArray, val key: Int)

    private data class PropertyInfo(
        val name: String,
        val kind: PropertyKind,
        val values: List<String>
    )

    private data class StringExpression(val literal: String, val modifiers: List<StringModifier>)
    private data class StringExpressionResult(val expression: StringExpression, val endIndex: Int)
    private data class CollectionExpressionResult(val elements: List<StringExpression>, val endIndex: Int)

    private sealed class ParsedInitializer {
        data class StringLiteral(val expression: StringExpression) : ParsedInitializer()
        data class CollectionLiteral(val expressions: List<StringExpression>) : ParsedInitializer()
    }

    private enum class PropertyKind(val returnType: TypeName) {
        STRING(STRING_TYPE),
        STRING_ARRAY(ARRAY_OF_STRING),
        LIST(LIST_OF_STRING),
        MUTABLE_LIST(MUTABLE_LIST_OF_STRING),
        SET(SET_OF_STRING),
        MUTABLE_SET(MUTABLE_SET_OF_STRING)
    }

    private sealed interface StringModifier {
        object TrimIndent : StringModifier
        data class TrimMargin(val prefix: String?) : StringModifier
    }

    private fun String.toAccessorSuffix(): String {
        if (isEmpty()) return this
        val lowercased = this.lowercase()
        return buildString(lowercased.length) {
            var capitalizeNext = false
            for (char in lowercased) {
                when {
                    char == '_' || char == '-' -> capitalizeNext = true
                    capitalizeNext -> {
                        append(char.uppercaseChar())
                        capitalizeNext = false
                    }
                    else -> append(char)
                }
            }
        }
    }

    private companion object {
        private val SUPPORTED_COLLECTION_INITIALIZERS = setOf(
            "arrayOf",
            "listOf",
            "mutableListOf",
            "setOf",
            "mutableSetOf"
        )
    }
}

class StringObfuscateProcessorProvider : SymbolProcessorProvider {
    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor {
        return StringObfuscateProcessor(environment.codeGenerator, environment.logger)
    }
}
