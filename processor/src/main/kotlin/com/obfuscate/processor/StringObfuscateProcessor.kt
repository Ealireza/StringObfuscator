package com.obfuscate.processor

import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.*
import com.google.devtools.ksp.validate
import com.obfuscate.annotation.StringObfuscate
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ksp.toClassName
import com.squareup.kotlinpoet.ksp.writeTo
import java.security.SecureRandom
import java.util.Base64

class StringObfuscateProcessor(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger
) : SymbolProcessor {

    override fun process(resolver: Resolver): List<KSAnnotated> {
        val symbols = resolver.getSymbolsWithAnnotation(StringObfuscate::class.qualifiedName!!)
        val validSymbols = symbols.filter { it is KSClassDeclaration && it.validate() }

        validSymbols.forEach { symbol ->
            if (symbol is KSClassDeclaration) {
                processClass(symbol)
            }
        }

        return symbols.filterNot { it.validate() }.toList()
    }

    private fun processClass(classDeclaration: KSClassDeclaration) {
        val packageName = classDeclaration.packageName.asString()
        val className = classDeclaration.simpleName.asString()
        val generatedClassName = "${className}Obfuscated"

        logger.info("Processing @StringObfuscate on $packageName.$className")

        // Find all string properties
        val stringProperties = classDeclaration.getAllProperties()
            .filter { it.type.resolve().declaration.qualifiedName?.asString() == "kotlin.String" }
            .toList()

        if (stringProperties.isEmpty()) {
            logger.warn("No string properties found in $className")
            return
        }

        // Generate obfuscated class
        val fileSpec = FileSpec.builder(packageName, generatedClassName)
            .addType(generateObfuscatedClass(classDeclaration, className, stringProperties))
            .addComment("Generated by StringObfuscate KSP - DO NOT EDIT")
            .build()

        fileSpec.writeTo(codeGenerator, Dependencies(true, classDeclaration.containingFile!!))
    }

    private fun generateObfuscatedClass(
        original: KSClassDeclaration,
        originalName: String,
        properties: List<KSPropertyDeclaration>
    ): TypeSpec {
        val className = "${originalName}Obfuscated"

        val classBuilder = TypeSpec.objectBuilder(className)
            .addKdoc("Obfuscated version of $originalName\nGenerated at compile time for security")

        // Add obfuscated data storage
        val obfuscatedDataType = MAP.parameterizedBy(STRING, PAIR.parameterizedBy(BYTE_ARRAY, BYTE))
        classBuilder.addProperty(
            PropertySpec.builder("obfuscatedData", obfuscatedDataType, KModifier.PRIVATE)
                .initializer(buildObfuscatedDataMap(properties))
                .build()
        )

        // Add getter methods for each property
        properties.forEach { prop ->
            val propName = prop.simpleName.asString()
            classBuilder.addFunction(
                FunSpec.builder("get${propName.replaceFirstChar { it.uppercase() }}")
                    .returns(STRING)
                    .addCode("""
                        val (encoded, key) = obfuscatedData["$propName"]!!
                        return deobfuscate(encoded, key)
                    """.trimIndent())
                    .build()
            )
        }

        // Add deobfuscate method
        classBuilder.addFunction(generateDeobfuscateFunction())

        return classBuilder.build()
    }

    private fun buildObfuscatedDataMap(properties: List<KSPropertyDeclaration>): CodeBlock {
        val codeBlock = CodeBlock.builder()
        codeBlock.add("mapOf(\n")
        codeBlock.indent()

        properties.forEachIndexed { index, prop ->
            val propName = prop.simpleName.asString()

            // Get the actual string value from the initializer if it exists
            val originalValue = extractStringValue(prop) ?: ""

            // Generate obfuscation
            val (obfuscatedBytes, xorKey) = obfuscateString(originalValue)
            val base64Encoded = Base64.getEncoder().encodeToString(obfuscatedBytes)

            codeBlock.add("\"$propName\" to (")
            codeBlock.add("android.util.Base64.decode(\"$base64Encoded\", android.util.Base64.DEFAULT)")
            codeBlock.add(" to $xorKey.toByte())")

            if (index < properties.size - 1) {
                codeBlock.add(",\n")
            }
        }

        codeBlock.unindent()
        codeBlock.add("\n)")
        return codeBlock.build()
    }

    private fun extractStringValue(prop: KSPropertyDeclaration): String? {
        // Try to get the value from the initializer
        // Note: This works for compile-time constants
        return null // Will be handled by user to provide values or use const vals
    }

    private fun obfuscateString(input: String): Pair<ByteArray, Int> {
        val random = SecureRandom()
        val xorKey = random.nextInt(256)

        val bytes = input.toByteArray(Charsets.UTF_8)

        // XOR encryption
        val xored = bytes.map { (it.toInt() xor xorKey).toByte() }.toByteArray()

        // Add entropy by shuffling bits in a reversible way
        val obfuscated = xored.map { byte ->
            val b = byte.toInt() and 0xFF
            val shuffled = ((b shl 3) or (b ushr 5)) and 0xFF
            shuffled.toByte()
        }.toByteArray()

        return Pair(obfuscated, xorKey)
    }

    private fun generateDeobfuscateFunction(): FunSpec {
        return FunSpec.builder("deobfuscate")
            .addModifiers(KModifier.PRIVATE, KModifier.INLINE)
            .addParameter("encoded", BYTE_ARRAY)
            .addParameter("key", BYTE)
            .returns(STRING)
            .addCode("""
                // Reverse bit shuffling
                val unshuffled = encoded.map { byte ->
                    val b = byte.toInt() and 0xFF
                    val original = ((b shr 3) or (b shl 5)) and 0xFF
                    original.toByte()
                }.toByteArray()

                // XOR decryption
                val decrypted = unshuffled.map { (it.toInt() xor key.toInt()).toByte() }.toByteArray()

                return String(decrypted, Charsets.UTF_8)
            """.trimIndent())
            .build()
    }
}

class StringObfuscateProcessorProvider : SymbolProcessorProvider {
    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor {
        return StringObfuscateProcessor(environment.codeGenerator, environment.logger)
    }
}
